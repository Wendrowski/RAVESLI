Инструкция(Statement) - наименьшая независимая единица в языке. Аналог предложения. Заканчивается ";".
Распространённые виды стейтментов:
	- Стейтмент объявления (declaration statement) (int x;)
	- Стейтмент присвоения (assignment statement) (x = 5;)
	- Стейтмент вывода (std::cout << x;)

ВЫРАЖЕНИЕ(Expressions) - Математический объект, который создаётся для проведения вычислений. Является частью Стейтмента.
Могут содержать:
	- Цифры и числа (2, 45)
	- Буквенные переменные (x, y)
	- Операторы (+, -)
	- Функции

ФУНКЦИЯ(Function) 
	- фрагмент программного кода, к которому можно обратиться из другого места программы.
	- Последовательность инструкций (Которые объединяются в блоки). Каждая программа содержит главную функцию main().

БИБЛИОТЕКА(Library) - Набор скомпилированного кода(например функций), который упакован для повторного использования в других программах.

КОММЕНТАРИИ
	- Однострочные //
	- Могострочные /*   */

ПЕРЕМЕННАЯ(Variable) - поименованная область памяти, адрес которой можно использовать для осуществления доступа к данными и изменять значение в ходе выполнения программы.

	L-VALUE - Значение, имеющее собственный адрес в памяти. Все переменные являются l-value - g, n, z.
	R-VALUE - Значение, не имеющее постоянного адреса в памяти. Единичные числа или выражения - 3, 213, 3x + 2.

ОБЪЯВЛЕНИЕ(Declaration) - это стейтмент, который сообщает компилятору о существовании идентификатора и о его типе - int func(int g, int r); int x; 

ПРИСВАИВАНИЕ(Assignment) — Механизм связывания, позволяющий динамически изменять связи имён объектов данных (как правило, переменных) с их значениями(Знак "=").
	- КОПИРУЮЩЕЕ П.- Когда переменной присваивается значение после её объявления (не в момент объявления): int nValue; nValue = 5;

ИНИЦИАЛИЗАЦИЯ(Initialization)(= ОПРЕДЕЛЕНИЕ) - Одновременное Объявление и Присваивание - int r = 0;

	- КОПИРУЮЩАЯ(Инициализация копированием) с помощью оператора "=": int nValue = 5;
	- ПРЯМАЯ - с помощью круглых скобок: int nValue(5);
	- Uniform-Инициализация(Добавлена в C++11) Для работы со всеми типами данных: int nValue{5}. Преимущество - Нельзя присвоить значение неподдерживаемого типа.
	  ПО УМОЛЧАНИЮ(Инициализация с пустыми фигурными скобками) - Переменной присваивается 0: int nValue{};  

	:: - Оператор разрешения области видимости.
	STD::COUT - Объект, который используется для вывода данных в Выходной поток; Оператор ВЫВОДА - "<<".
	STD::CIN - Объект, который используется для ввода данных во Входной поток;  Опереатор ВВОДА - ">>".
	STD::ENDL - Объект, который вставляет символ новой строки(\n).

CALLER - Функция, в которой находится вызов другой функции. Функция, которую вызывают называется ВЫЗЫВАЕМОЙ ФУНКЦИЕЙ.

ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ 
	- Тип возвращаемого значения указывается при объявлении функции перед её именем.
	- Оператор RETURN - Возвращает значение.
	- VOID - тип возврата, означающий, что функция НИЧЕГО не возвращает.
	- Функция может возвращать ТОЛЬКО ОДНО значение обратно в Caller. Весь следующий за оператором return код - игнорируются.
	- Вложенные функции ЗАПРЕЩЕНЫ.

После выполнения всех инструкций, функция main() - Передаёт целочисленное значение программному загрузчику. Если не было ошибок, то "0".

ПАРАМЕТР ФУНКЦИИ — Это переменная, которая используется в функции, и значение которой предоставляет caller (вызывающий объект). 
	- Параметры указываются при объявлении функции в круглых скобках. Если их много, то они перечисляются через запятую.
	- Параметры каждой функции действительны только внутри этой функции. F(x) & G(x) - Нет конфликта.

АРГУМЕНТ ФУНКЦИИ - Это значение, которое передается из caller-а в функцию и которое указывается в скобках при вызове функции в caller-е.
При вызове функции, все её параметры создаются как локальные переменные, а значение каждого из аргументов копируется в соответствующий параметр (локальную переменную).
Этот процесс называется ПЕРЕДАЧЕЙ ПО ЗНАЧЕНИЮ.

ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННОЙ - определяет, кто может видеть и использовать переменную во время её существования.
	- И параметры функции, и переменные, которые объявлены внутри функции, имеют локальную область видимости.
	- Другими словами, эти параметры и переменные используются только внутри функции, в которой они объявлены. 
	- Локальные переменные создаются в точке объявления и уничтожаются, когда выходят из области видимости.
	- Локальная область видимости предотвращает возникновение конфликта имён.

КЛЮЧЕВЫЕ СЛОВА - Зарезервированный набор из 84х слов для собственного использования в C++. 

ИДЕНТИФИКАТОР(Identifier) - Уникальный признак объекта, позволяющий отличать его от других объектов, то есть идентифицировать.
	- Это имя переменной, функции, класса или другого объекта в языке C++.
	- Не может быть ключевым словом.
	- Может состоять только из латинских букв, цифр и символов подчёркивания; Остальные символы и пробелы - ЗАПРЕЩЕНЫ.
	- Должен начинаться с буквы любого регистра. Не может начинаться с цифры.
	- C++ - регистрозависим. Поэтому nValue ≠ NValue ≠ NVALUE.
	- Переменные и функции начинаются с буквы нижнего регистра. Если имя переменной или функции состоит из нескольких слов - используется camelCase.

ЛИТЕРАЛ(ЛИТЕРАЛЬНАЯ КОНСТАНТА) - Фиксированное значение, число записанное в исходном коде(1, 3.14159). 
	- Литерал, т.к. невозможно изменить значение, литера - т.к. фигурирует в тексте программы. 
	- Является неадрсуемой величиной, хотя и хранится в регистрах машины. Нет способа узнать его адрес.
	- Имеет тип(1 - int, 3.14159 - double).

ОПЕРАНДЫ - Данные, с которыми работает выражение(Литералы, переменные и функции).

ОПЕРАТОР - Отображение между множествами, в котором каждое из них наделено какой-либо дополнительной структурой (порядком, топологией, алгебраическими операциями).
	- С их помощью мы можем объединить операнды для получения нового значения.
	- УНАРНЫЕ - Работают с одним операндом(-7).
	- БИНАРНЫЕ - Работают с двумя операндами(5 + 2).
	- ТЕРНАРНЫЕ - Работают с тремя операндами(В C++ есть лишь один тернарный оператор).
	- Некоторые операторы могу быть как унарными, так и бинарными("-": -1 & 1 - 2).

ПРОБЕЛЫ - относятся к символам, используемым в форматировании кода, вместе с символами табуляции и разрывом строки. Компилятор, игнорирует пробелы, кроме двух исключений:
	- Цитируемый текст
	- Однострочные комментарии

ПРЕДВАРИТЕЛЬНО ОБЪЯВЛЕНИЕ - Сообщает компилятору о существовании идентификатора ДО его фактического определения. Для этого используется прототип функции.

ПРОТОТИП ФУНКЦИИ(Полноценный) - Состоит из типа возврата функции, её имени и параметров (тип + имя параметра). В кратком прототипе отсутствуют имена параметров функции.
	- int func(int g, int r); (Точка с запятой - обязательно)

ОПРЕДЕЛЕНИЕ - Реализует (вызывает выделение памяти) идентификатор. int func(int x, int y) {z = x + y; return z;}
	- Определение необходимо для корректной работы линкера.
	- Объявление — это всё, что необходимо для корректной работы компилятора, но недостаточно для корректной работы линкера.
	- Определение — это то, что обеспечит корректную работу как компилятора, так и линкера.

ЗАГОЛОВОЧНЫЙ ФАЙЛ(Заголовок) - Тип файлов для удобного хранения набора объявлений объектов для их последующего использования в других программах. Расширение ".h".
	- объект в заголовках только объявляется. Пример: cout объявлен в заголовке <stream> а определяется в Стандартной Библиотеке C++(SRL, подключается при линкинге).
	- Определения в заголовочных файлах записывать не принято. 
Состоит из:
	- ДИРЕКТИВЫ ПРЕПРОЦЕССОРА — В частности, header guards, которые предотвращают вызов заголовочного файла больше одного раза из одного и того же файла
	- СОДЕРЖИМОГО ЗАГОЛОВОЧНОГО ФАЙЛА - Набора объявлений.

	<> - Файл написан не нами - следует искать в системных директориях.
	"" - Файл написан нами - следует искать в директории текущего проекта.

ПРЕПРОЦЕССОР - Отдельная программа, выполняемая перед компиляцией. Препроцессор просматривает код сверху вниз в поиске директив. 

ДИРЕКТИВА - Специальная команда, начинающаюсяя на "#" и не заканчивающаяся ";".
	- #include - C её помощью препроцессор копирует содержимое подключаемого файла в текущий.
	- #define - Используется для создания макросов.

МАКРОС — это правило, которое определяет конвертацию идентификатора в указанные данные.
	- Макросы-Функции. Ведут себя как функции. Их использование считается опасным.
	- Макросы-Объекты. Определяется так: "#define идентификатор" или "#define идентификатор текст_замена".
	  Поскольку это дерективы препроцессора а не простые инструкции, ";" - не заканчиваются.

МАКРОКОНСТАНТА - Идентификатор Макроса(Рекомендуется выбирать безобразные имена)

	Когда препроцессор встречает макросы-объекты с текст_замена, то любое дальнейшее появление "идентификатор" заменяется на "текст_замена". 
	Идентификатор пишется заглавными буквами с символами подчёркивания вместо пробелов.

УСЛОВНАЯ КОМПИЛЯЦИЯ - Директивы препроцессора условной компиляции позволяют определить, при каких условиях код будет компилироваться, а при каких — нет.
	- #ifdef позволяет препроцессору проверить, было ли значение ранее определено с помощью #define. Если да, то код между #ifdef и #endif скомпилируется. Нет - игнор.
	- #ifndef позволяет проверить, не было ли значение ранее определено
	- #endif замыкающая директива

SOURCE FILE - Исходный файл до препроцессинга
TRANSLATION UNIT - Единица Трансляции - Код после препроцессинга
При Препроцессировании - Выполняются макроподстановки и с помощью директив #include к тексту добавляется содержимое заголовочных файлов

HEADER GUARDS - Директивы условной компиляции, предотвращающие дублирование кода. Состоят из следующего:
	#ifndef "SOME_UNIQUE_NAME_HERE"
	#define "SOME_UNIQUE_NAME_HERE"
	//main code
	#endif

#pragma once - Более простая альтернатива header guards. Понимаема не всеми компиляторами. Лучше использовать hg.

ФУНДАМЕНТАЛЬНЫЕ(ВСТРОЕННЫЕ) ТИПЫ ДАННЫХ

	       Категория			Тип			   Значение		Пример
	 
	 Логический(Boolean) | bool				  | true/false 		   | true
	 Символьный 	     | char, wchar_t, char16_t, char32_t  | Один из ASCII-символов | 'c'
	 С плавающей запятой | float, double, long double	  | Десятичная дробь	   | 3.14159
	 Целочисленный       | short, int, long, long long	  | Целое число		   | 64
	 Пустота             | void				  | Пустота		   |________


РАЗМЕР ОСНОВНЫХ ТИПОВ ДАННЫХ		
	
	 КАТЕГОРИЯ	    МИН.РАЗМЕР		 КАТЕГОРИЯ		МИН.РАЗМЕР		  КАТЕГОРИЯ		МИН.РАЗМЕР		  КАТЕГОРИЯ		МИН.РАЗМЕР

	Логический				Символьный  					Целочисленный					С плавающей запятой
	bool		   |	1		char		   |	   1			short		   |	   2			float              |       4
	                   |			wchar_t		   |	   1			int		   |	   2			double		   |	   8
			   | 			char16_t	   |	   2			long		   |	   4			long double	   |	   8
			   |			char32_t	   |	   4			long long	   |	   8

		
Размер переменных отличается на различной архитектуре и компиляторах. C++ гарантирует лишь мин. размер.

ОПЕРАТОР sizeof - Унарный оператор, вычисляет и возвращает размер переменной или тип в байтах. Не используется с void.
	Один из трёх операторов, являющихся словом (ещё есть new и delete).

ЭКСПОНЕНЦИАЛЬНАЯ ЗАПИСЬ ЧИСЛА - Мантисса * 10^Экспонент - 16000 = 1.6E4 Мантисса - Значащая часть числа, Экспонент - Порядок

ПЕРЕОПРЕДЕЛЕНИЕ ТОЧНОСТИ ЧИСЛА - Функция std::setprecision() из заголовочного файла <iomanip> 

СПЕЦИАЛЬНЫЕ ТИПЫ С ПЛАВАЮЩЕЙ ТОЧКОЙ:
	- inf(Infinity) - +a/0, -a/0 - Бесконечность (Бывает положительная и отрицательная)
	- nan(Not A Number) - 0/0 - Не Число (Есть несколько видов)

ЛОГИЧЕСКИЕ ЗНАЧЕНИЯ - Обрабатываются не как true/false, а как 1/0

МАНИПУЛЯТОРЫ ФОРМАТИРОВАНИЯ - std::boolalpha/std::noboolalpha - Используется для того, чтобы std::cout выводил true/false вместо целых чисел и наоборот

"!" - Логический оператор НЕ - !true = false

ЛИТЕРАЛЬНЫЕ КОНСТАНТЫ (или просто «литералы») — это значения, которые вставляются непосредственно в код. Поскольку они являются константами, то их значения изменить нельзя.
	- bool myNameIsAlex = true; // true - это литеральная константа типа bool
	- int x = 5; // 5 - это литеральная константа типа int
	- int y = 2 * 3; // 2 и 3 - это литеральные константы типа int

По умолчанию литеральные константы типа с плавающей точкой имеют тип double. Для конвертации литеральных констант в тип float можно использовать суффикс f или F:
	- float fValue = 5.0f; // тип float
	- double d = 6.02e23; // тип double (по умолчанию)

Язык C++ также поддерживает литералы типов string и char:
	- char c = 'A'; // 'A' - это литерал типа char 
	- std::cout << "Hello, world!"; // "Hello, world!" - это литерал строки C-style
	- std::cout << "Hello," " world!"; // C++ связывает последовательные литералы типа string

Для использования литерала из ВОСЬМЕРИЧНОЙ системы счисления, используйте префикс 0 (ноль): int x = 012; 
Для использования литерала из ШЕСТНАДЦАТЕРИЧНОЙ системы счисления, используйте префикс 0x: int x = 0xF;

0011 1010 0111 1111 1001 1000 0010 0110(BIN) = 3A7F 9826(HEX).Такой удобный/сжатый формат является преимуществом шестнадцатеричной системы счисления, поэтому шестнадцатеричные значения часто используются для представления адресов памяти или необработанных значений в памяти.

В C++14 можно использовать бинарные (двоичные) литералы, добавляя префикс 0b:
	- bin = 0b1010; // присваиваем переменной бинарный литерал 0000 1010 
    	- bin = 0b11110000; // присваиваем переменной бинарный литерал 1111 0000 

В C++14 также добавили возможность использовать одинарную кавычку ' в качестве разделителя цифр:
	- int bin = 0b1011'0010; // присваиваем переменной бинарный литерал 1011 0010

МАГИЧЕСКОЕ ЧИСЛО — это хорошо закодированный литерал (обычно, число) в строке кода, который не имеет никакого контекста.
	- int maxStudents = numClassrooms * 30;

Чтобы сделать переменную КОНСТАНТОЙ — Следует использовать ключевое слово const перед типом переменной или после него.
	- const double gravity { 9.8 }; // предпочтительнее использовать const перед типом данных

КОНСТАНТЫ должны быть инициализированы при объявлении. Изменить их значения с помощью операции присваивания нельзя:
	- const double gravity { 9.8 };
	- gravity = 9.9; // не допускается - ошибка компиляции
Объявление КОНСТАНТЫ без её инициализации также вызовет ошибку компиляции:
	- const double gravity; // ошибка компиляции, константа должна быть инициализирована
КОНСТАНТЫ могут быть инициализированы и с помощью неконстантных значений:
	- const int usersAge (age); // в дальнейшем значение переменной usersAge не может быть изменено

CONST полезно в параметре функции: void printInteger(const int myValue)
	- Константа-параметр сообщает и гарантирует, что функция не изменит значение переменной myValue.

ВРЕМЯ КОМПИЛЯЦИИ(COMPILE TIME) - Длительность процесса компиляции. Компилятор проверяет синтаксис и конвертирует код в объектные файлы.

ВРЕМЯ ВЫПОЛНЕНИЯ(RUNTIME) - Временной промежуток с момента старта выполнения программы и до момента окончания её работы. Код выполняется построчно.

ДВА ВИДА КОНСТАНТ:

	- КОНСТАНТЫ ВРЕМЕНИ ВЫПОЛНЕНИЯ - Их значения определяются только во время выполнения программы. Компилятор не может определить их значения во время компиляции.
	  Зависят от пользовательсткого ввода или от значения, переданного в функцию (usersAge, myValue)

	- КОНСТАНТЫ ВРЕМЕНИ КОМПИЛЯЦИИ - Их значения определяются во время компиляции программы. Например, переменная со значением силы тяжести Земли.
	  Её значение определяется до начала выполнения программы, во время её написания.

Компилятор постоянно отслеживает, к какому из двух типов относится та или иная константа. в C++11 упростили эту задачу, добавив 

СПЕЦИФИКАТОР CONSTEXPR - Сообщает компилятору, что текущая переменная является константой времени компиляции: constexpr double accOfGravity (9.8);

ПРАВИЛО: Любая переменная, которая не должна изменять свое значение после инициализации, должна быть объявлена с помощью спецификатора const (или constexpr).

СИМВОЛЬНАЯ КОНСТАНТА — это литерал (магическое число), но с идентификатором.

Есть два способа объявления символьных констант:
	- С помощью спецификатора const: const int maxStudentsPerClass { 30 }; const int maxNameLength { 30 };
	- С помощью макросов-объектов с текстом-заменой: #define MAX_STUDENTS_PER_CLASS 30 ... int max_students = numClassrooms * MAX_STUDENTS_PER_CLASS;
	  Значения констант, объявленных с помощью директивы #define, не отображаются в отладчике => Выше вероятность возникновения конфликта имён.

ПРАВИЛО: Следует использовать спецификатор const для создания символьных констант.

ПРИОРИТЕТ ОПЕРАЦИИ - Последовательность, с которой выполняются операторы

АССОЦИАТИВНОСТЬ - Правила направления выполнения операций (R=>L & L<=R)

POW() - Функция возведения в степень. Находится в заголовочном файле cmath. Возвращает значения типа double. Возможны ошибки округления. double x = pow (base, exponent) 

Унарный плюс    			+ 	+x 	Значение x
Унарный минус   			- 	-x 	Отрицательное значение x

Сложение				+	x + y	x плюс y
Вычитание				−	x − y	x минус y
Умножение				*	x * y	x умножить на y
Деление					/	x / y	x разделить на y
Деление с остатком  			%	x % y	Остаток от деления x на y (работает только с целочисленными операторами)

Присваивание				=	x = y	Присваиваем значение y переменной x
Сложение с присваиванием		+=	x += y Добавляем y к x
Вычитание с присваиванием		−=	x −= y	Вычитаем y из x
Умножение с присваиванием		*=	x *= y	Умножаем x на y
Деление с присваиванием			/=	x /= y	Делим x на y
Деление с остатком и 			%=	x %= y	Присваиваем остаток от деления x на y переменной x
С присваиванием

Префиксный инкремент (пре-инкремент)	++	++x	Инкремент x, затем вычисление x
Префиксный декремент (пре-декремент)	−−	−−x	Декремент x, затем вычисление x
Постфиксный инкремент (пост-инкремент)	++	x++	Вычисление x, затем инкремент x
Постфиксный декремент (пост-декремент)	−−	x−−	Вычисление x, затем декремент x

Больше					>	x > y	true, если x больше y, в противном случае — false
Меньше					<	x < y	true, если x меньше y, в противном случае — false
Больше или равно			>=	x >= y	true, если x больше/равно y, в противном случае — false
Меньше или равно			<=	x <= y	true, если x меньше/равно y, в противном случае — false
Равно					==	x == y	true, если x равно y, в противном случае — false
Не равно				!=	x != y	true, если x не равно y, в противном случае — false

sizeof				     sizeof     sizeof(type)/sizeof(variable) Возвращает размер типа данных или переменной в байтах

Запятая(Оператор Сотта)			,	x, y	Вычисляется x, затем вычисляется y, а затем возвращается значение y

Условный (Тернарный оператор)		?:	c ? x : y	Если c — ненулевое значение (true), то вычисляется x, в противном случае — y

Логическое НЕ				!	!x	true, если x — false и false, если x — true
Логическое И				&&	x && y	true, если x и y — true, в противном случае — false
Логическое ИЛИ				||	x || y	true, если x или y — true, в противном случае — false

Побитовый сдвиг влево			<<	x << y	Все биты в x смещаются влево на y бит
Побитовый сдвиг вправо			>>	x >> y	Все биты в x смещаются вправо на y бит
Побитовое НЕ				~	~x	Все биты в x меняются на противоположные
Побитовое И				&	x & y	Каждый бит в x И каждый соответствующий ему бит в y
Побитовое ИЛИ				|	x | y	Каждый бит в x ИЛИ каждый соответствующий ему бит в y
Побитовое исключающее ИЛИ (XOR)		^	x ^ y	Каждый бит в x XOR с каждым соответствующим ему битом в y

Присваивание с побитовым сдвигом влево	<<=	x <<= y	Сдвигаем биты в x влево на y бит
Присваивание с побитовым сдвигом вправо	>>=	x >>= y	Сдвигаем биты в x вправо на y бит
Присваивание с побитовой операцией ИЛИ	|=	x |= y	Присваивание результата выражения x | y переменной x
Присваивание с побитовой операцией И	&=	x &= y	Присваивание результата выражения x & y переменной x
Присваивание с побитовой операцией 	^=	x ^= y	Присваивание результата выражения x ^ y переменной x
исключающего ИЛИ			

Правило: При работе с побитовыми операторами следует использовать целочисленные типы данных unsigned.


БЛОКИ СТЕЙТМЕНТОВ (СОСТАВНЫЕ ОПЕРАТОРЫ) - Группы стейтментов, обрабатываемые компилятором как одна инструкция. Обозначение {...}, ";" - НЕ ставится.

ВЛОЖЕННЫЕ БЛОКИ - Блоки могут содержать другие блоки (Внешний/Внутренний(Вложенный)).

ОБЛАСТЬ ВИДИМОСТИ - Определяет, где можно использовать переменную. 

ПРОДОЛЖИТЕЛЬНОСТЬ ЖИЗНИ(ВРЕМЯ ЖИЗНИ) - Определяет, где переменная создаётся и уничтожается.

ЛОКАЛЬНАЯ ПЕРЕМЕННАЯ - Переменная определённая внутри блока. Имеют АВТОМАТИЧЕСКУЮ ПРОДОЛЖИТЕЛЬНОСТЬ ЖИЗНИ. Создаются в точке определения, уничтожаются при выходе из блока.
	 - Имеют ЛОКАЛЬНУЮ ОБЛАСТЬ ВИДИМОСТИ. 

В разных функциях могут находиться переменные и параметры с одинаковыми именами - Конфликта имён - НЕ возникает. 
Переменные внутри Внешнего блока могу быть видны внутри Вложенного. 

Переменная внутри внешнего блока может иметь одно имя с переменной внутри вложенного блока. Это называется СОКРЫТИЕМ ИМЁН. 

ПРАВИЛО: Следует избегать использования вложенных переменных с именами, идентичными именам внешних переменных.

ПРАВИЛО: Следует определять переменные в наиболее ограниченной области видимости.


ГЛОБАЛЬНЫМИ называются переменные, которые объявлены вне блока. Они имеют СТАТИЧЕСКУЮ ПРОДОЛЖИТЕЛЬНОСТЬ ЖИЗНИ, т.е. создаются при запуске программы и уничтожаются при её завершении. 	

	Глобальные переменные имеют ГЛОБАЛЬНУЮ ОБЛАСТЬ ВИДИМОСТИ (или «файловую область видимости»), т.е. их можно использовать в любом месте файла, после их объявления.
	Глобальные переменные объявляют в верхней части кода, ниже директив #include, но выше любого другого кода.
	При сокрытии глобальной переменной переменной локальной с тем же именем, можно обратиться именно к глобальной переменной через оператор ::

СВЯЗЬ ПЕРЕМЕННОЙ - определяет, относятся ли несколько упоминаний одного идентификатора к одной и той же переменной или нет.

	Переменная без связей — это переменная с локальной областью видимости, которая относится только к блоку, в котором она определена. Это обычные локальные переменные. Две переменные с 	одинаковыми именами, но определенные в разных функциях, не имеют никакой связи — каждая из них считается независимой единицей.

	Переменная, имеющая внутренние связи, называется ВНУТРЕННЕЙ ПЕРЕМЕННОЙ (или «статической переменной»). Она может использоваться в любом месте файла, в котором определена, но не 	относится к чему-либо вне этого файла.	

	Переменная, имеющая внешние связи, называется ВНЕШНЕЙ ПЕРЕМЕННОЙ. Она может использоваться как в файле, в котором определена, так и в других файлах.

Если необходимо сделать глобальную переменную внутренней, следует использовать ключевое слово static: static int x;
Если необходимо сделать глобальную переменную внешней, следует использовать ключевое слово extern: extern double y;



По умолчанию, неконстантные переменные, объявленные вне блока, считаются внешними. Однако константные переменные, объявленные вне блока, считаются внутренними.

Функции имеют такие же свойства связи, что и переменные. По умолчанию они имеют внешнюю связь, которую можно сменить на внутреннюю с помощью ключевого слова static.

Предварительные объявления функций не нуждаются в ключевом слове extern. Компилятор может определить сам (по телу функции): Определяется ли функция или пишется её прототип.

ОБЛАСТЬ ВИДИМОСТИ ИДЕНТИФИКАТОРА определяет, где он доступен для использования. К идентификатору, который находится вне области видимости, доступ закрыт.
Переменные с ЛОКАЛЬНОЙ/БЛОЧНОЙ ОБЛАСТЬЮ ВИДИМОСТИ доступны только в пределах блока, в котором они объявлены. Это:
	- локальные переменные
	- параметры функции

Переменные с ГЛОБАЛЬНОЙ/ФАЙЛОВОЙ ОБЛАСТЬЮ ВИДИМОСТИ доступны в любом месте файла. Это:
	- глобальные переменные

Так же, как мы используем префикс g_ с глобальными переменными, префикс s_ принято использовать со статическими переменными. 
Обратить внимание - внутренние глобальные переменные (которые объявлены с использованием static) остаются с префиксом g_, а не с префиксом s_.

ПР+ОДОЛЖИТЕЛЬНОСТЬ ЖИЗНИ переменной определяет, где она создается и где уничтожается.

Переменные с АВТОМАТИЧЕСКОЙ ПРОДОЛЖИТЕЛЬНОСТЬЮ ЖИЗНИ создаются в точке определения и уничтожаются при выходе из блока, в котором определены. Это:
	- обычные локальные переменные

Переменные со СТАТИЧЕСКОЙ ПРОДОЛЖИТЕЛЬНОСТЬЮ ЖИЗНИ создаются, когда программа запускается, и уничтожаются при её завершении. Это:
	- глобальные переменные
	- статические локальные переменные

Переменные с ДИНАМИЧЕСКОЙ ПРОДОЛЖИТЕЛЬНОСТЬЮ ЖИЗНИ создаются и уничтожаются по запросу программиста. Это:
	- динамические переменные

СВЯЗЬ идентификатора определяет, относятся ли несколько упоминаний одного идентификатора к одному и тому же идентификатору или нет.

   Идентификаторы БЕЗ СВЯЗЕЙ — это идентификаторы, которые ссылаются сами на себя. Это:
	- обычные локальные переменные

   пользовательские типы данных, такие как enum, typedef и классы, объявленные внутри блока.

   Идентификаторы с ВНУТРЕННЕЙ СВЯЗЬЮ доступны в любом месте файла, в котором они объявлены. Это:
	- статические глобальные переменные (инициализированные или неинициализированные)
	- константные глобальные переменные
	- статические функции 

   Идентификаторы с ВНЕШНЕЙ СВЯЗЬЮ доступны как в любом месте файла, в котором они объявлены, так и в других файлах (через предварительное объявление). Это:
	- обычные функции
	- неконстантные глобальные переменные (инициализированные или неинициализированные)
	- внешние константные глобальные переменные
	- определяемые пользователем типы данных, такие как enum, typedef и классы с глобальной областью видимости 

Идентификаторы с внешней связью могут вызвать ошибку дублирования определений, если определения скомпилированы в более чем одном файле .cpp.

Функции по умолчанию имеют внешнюю связь, что можно изменить с помощью ключевого слова static (на внутреннюю связь).

Можно заметить, что глобальные типы данных имеют внешнюю связь, но их определения не вызывают ошибки линкера при использовании в нескольких файлах.
Это связано с тем, что типы, шаблоны и внешние встроенные функции являются исключениями из правила, и это позволяет им быть определенными более чем в одном файле, при условии, что эти определения идентичны. В противном случае, они не были бы так полезны.


С помощью ПРЕДВАРИТЕЛЬНОГО ОБЪЯВЛЕНИЯ мы можем получить доступ к функции или переменной из другого файла:

				Тип					Пример				Примечание

Предварительное объявление функции				void foo(int x);	Только прототип, без тела функции
Предварительное объявление неконстантной глобальной переменной	extern int g_x;		Переменная должна быть инициализирована
Предварительное объявление константной глобальной переменной	extern const int g_x;	Переменная должна быть инициализирована


ПРОСТРАНСТВО ИМЁН определяет область кода, в которой гарантируется уникальность всех идентификаторов. По умолчанию, ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ и ОБЫЧНЫЕ ФУНКЦИИ определены в ГЛОБАЛЬНОМ
ПРОСТРАНСТВЕ ИМЁН.

Чтобы избежать ситуаций, когда два независимых объекта имеют идентификаторы, которые могут конфликтовать друг с другом при совместном использовании, язык C++ позволяет объявлять собственные ПРОСТРАНСТВА ИМЁН через ключевое слово namespace. Всё, что объявлено внутри пользовательского пространства имен, — принадлежит только этому пространству имен (а не глобальному).

ПЕРВЫЙ СПОСОБ указать компилятору искать идентификатор в определенном ПРОСТРАНСТВЕ ИМЁН — это использовать название необходимого пространства имен вместе с оператором разрешения области видимости (::) и требуемым идентификатором - STD::COUT

Одни ПРОСТРАНСТВА ИМЁН могут быть вложены в другие пространства имен. namespace Boo { namespace Doo { const int g_x = 7;}} 
	- Поскольку Doo находится внутри Boo, то доступ к g_x осуществляется через Boo::Doo::g_x

Так как это не всегда удобно и эффективно, то C++ позволяет создавать псевдонимы для пространств имен: 
	- namespace Foo = Boo::Doo; // Foo теперь считается как Boo::Doo

Вложенность пространств имен не рекомендуется использовать, так как при неумелом использовании увеличивается вероятность возникновения ошибок и дополнительно усложняется логика программы.

USING-СТЕЙТМЕНТЫ - Альтернативы постоянному использованию library_name::
	- USING ОБЪЯВЛЕНИЯ - int main() {using std::cout;...} Менее предпочтительно, чем использование префикса std::
	- USING ДИРЕКТИВЫ - int main() {using namespace std;...} Следует избегать их использования, насколько это возможно

Если «using-объявление» или «using-директива» используются в блоке - они применяются только внутри этого блока (по обычным правилам локальной области видимости).
Помещение их вне тела функции влечёт за собой "вытаскивание" всех имён из библиотеки (например, std) в глобальную область видимости, провоцируя конфликты имён.

ПРАВИЛО: Никогда не следует использовать using-стейтменты вне тела функций.

Как только один using-стейтмент был объявлен, его невозможно отменить или заменить другим using-стейтментом в пределах области видимости, в которой он был объявлен.
Лучшее, что возможно сделать - намеренно ограничить область применения using-стейтментов с самого начала, используя правила локальной области видимости:
int main () {{using namespace Boo;...} {using namespace Doo;...}}

ПРЕОБРАЗОВАНИЕ ТИПОВ ДАННЫХ - Процесс конвертации одного типа данных в другой. Оно может выполняться в четырёх случаях:
	- Присваивание или инициализация переменной значением другого типа данных: double k(4); k = 7;
	- Передача значения в функцию, где тип параметра — другой: void doSomething(long l){} doSomething(4);
	- Возврат из функции, где тип возвращаемого значения — другой: float doSomething(){ return 4.0;}
	- Использование бинарного оператора с операндами разных типов: double division = 5.0 / 4;

ДВА СПОСОБА ПРЕОБРАЗОВАНИЯ ТИПОВ:
	- ЯВНОЕ - когда компилятор автоматически конвертирует один фундаментальный тип данных в другой
	- НЕЯВНОЕ - когда разработчик использует один из операторов явного преобразования для выполнения конвертации объекта из одного типа данных в другой

НЕЯВНОЕ ПРЕОБРАЗОВАНЕ ТИПОВ(или «АВТОМАТИЧЕСКОЕ преобразование типов») выполняется всякий раз, когда требуется один фундаментальный тип данных, но предоставляется другой, и пользователь не указывает компилятору, как выполнить конвертацию (не использует явное преобразование типов через операторы явного преобразования).

ДВА ВИДА НЕЯВНОГО ПРЕОБРАЗОВАНИЯ:
	- ЧИСЛОВОЕ РАСШИРЕНИЕ
	- ЧИСЛОВАЯ КОНВЕРСИЯ

ЧИСЛОВОЕ РАСШИРЕНИЕ - Когда значение одного типа конвертируется в значение большего типа - long l(65); double d(0.11f);

ДВА ВИДА ЧИСЛОВЫХ РАСШИРЕНИЙ:

	- ИНТЕГРАЛЬНОЕ РАСШИРЕНИЕ (или «целочисленное расширение») - Включает в себя преобразование целочисленных типов, меньших, чем int (bool, char, unsigned char, signed char, unsigned short, signed short) в int (если это возможно) или unsigned int
	- РАСШИРЕНИЕ ТИПА С ПЛАВАЮЩЕЙ ТОЧКОЙ - Конвертация из типа float в тип double 

Интегральное расширение и расширение типа с плавающей точкой используются для преобразования «меньших по размеру» типов данных в типы int/unsigned int или double (они наиболее эффективны для выполнения разных операций).

ЧИСЛОВАЯ КОНВЕРСИЯ - Конвертация более крупного типа данных в аналогичный, но меньший по размеру, или конвертация происходит между разными типами данных: double d = 4; short s = 3;

В отличие от расширений, которые всегда безопасны, конверсии могут (но не всегда) привести к потере данных. Поэтому в любой программе, где выполняется неявная конверсия, компилятор будет выдавать предупреждение.

ОБРАБОТКА АРИФМЕТИЧЕСКИХ ВЫРАЖЕНИЙ - При обработке выражений компилятор разбивает каждое выражение на отдельные подвыражения. Арифметические операторы требуют, чтобы их операнды были одного типа данных. Чтобы это гарантировать, компилятор использует следующие правила:
	- Если операндом является целое число меньше (по размеру/диапазону) типа int, то оно подвергается интегральному расширению в int или в unsigned int
	- Если операнды разных типов данных, то компилятор вычисляет операнд с наивысшим приоритетом и неявно конвертирует тип другого операнда в такой же тип, как у первого

Приоритет типов операндов:

   - long double (самый высокий)/double/float/unsigned long long/long long/unsigned long/long/unsigned int/int (самый низкий)
   
Можно использовать оператор typeid (который находится в заголовочном файле typeinfo), чтобы узнать решающий тип в выражении. 

В языке C++ есть 5 видов операций явного преобразования типов:

   	- конвертация C-style (float x = (float)i1 / i2; float x = float(i1) / i2;) - BETTER AVOID USAGE!
	- применение оператора static_cast (static_cast<int>(c))
   	- применение оператора const_cast - AVOID USAGE!
   	- применение оператора dynamic_cast
        - применение оператора reinterpret_cast - AVOID USAGE!

Конвертация C-style не проверяется компилятором во время компиляции, поэтому она может быть неправильно использована, например, при конвертации типов const или изменении типов данных, 
без учета их диапазонов (что приведет к переполнению).

Основным преимуществом оператора static_cast является проверка его выполнения компилятором во время компиляции, что усложняет возможность возникновения непреднамеренных проблем.

STRING(Строка) - Последовательность символов, использующаяся для представления текста. СТРОКОВЫЕ ЛИТЕРАЛЫ помещаются в двойные ковычки.
	- В C++ тип String является частью стандартной библиотеки (Требуется подключать заголовочный файл #include <string>)

Строки можно выводить через std::cout

Оператор извлечения (>>) возвращает символы из входного потока данных только до первого пробела. Все остальные символы остаются внутри cin, ожидая следующего извлечения.

ФУНКЦИЯ STD::GETLINE() используется для извлечения ПОЛНОЙ СТРОКИ из входного потока данных (Вместе с пробелами)
	- Она принимает два параметра: первый — std::cin, второй — переменная типа string - std::getline(std::cin, myName);

когда вводится числовое значение, поток cin захватывает вместе с вашим числом и символ новой строки(\n). 
std::cin.ignore(32767, '\n'); // игнорируем символы перевода строки "\n" во входящем потоке длиной 32767 символов.

ПРАВИЛО: При вводе числовых значений следует удалять символ новой строки из входного потока данных с помощью std::cin.ignore().

valueX.length() - Является особой функцией класса std::string, называемой МЕТОДОМ.


Перечисление (или «перечисляемый тип») — это тип данных, где любое значение (или «перечислитель») определяется как символьная константа. 
Объявить перечисление можно с помощью ключевого слова enum

Объявление перечислений не требует выделения памяти. Только когда переменная перечисляемого типа определена (например, Colors paint = COLOR_RED;), 
только тогда выделяется память для этой переменной.

Каждый перечислитель отделяется запятой, а само перечисление заканчивается точкой с запятой.
Идентификаторы перечислений часто начинаются с заглавной буквы, а имена перечислителей вообще состоят только из заглавных букв. 
Поскольку перечислители вместе с перечислением находятся в едином пространстве имен, то имена перечислителей не могут повторяться в разных перечислениях
Распространено добавление названия перечисления в качестве префикса к перечислителям, например: ANIMAL_ или COLOR_, как для предотвращения конфликтов имен, 
так и в целях комментирования кода.

Каждому перечислителю автоматически присваивается целочисленное значение в зависимости от его позиции в списке перечисления. 
По умолчанию, первому перечислителю присваивается целое число 0, а каждому следующему — на единицу больше, чем предыдущему:

Каждому перечислителю автоматически присваивается целочисленное значение в зависимости от его позиции в списке перечисления. 
По умолчанию, первому перечислителю присваивается целое число 0, а каждому следующему — на единицу больше, чем предыдущему.

ПРАВИЛО: Не присваивать одинаковые значения двум перечислителям в одном перечислении, если на это нет веской причины.

Поскольку значениями перечислителей являются целые числа, то их можно присваивать целочисленным переменным, а также выводить в консоль (как переменные типа int)(int mypet = ANIMAL_PIG;).
Компилятор не будет неявно конвертировать целочисленное значение в значение перечислителя. Следующее вызовет ошибку компиляции: Animals animal = 7;
Тем не менее, возможно сделать подобное с помощью оператора static_cast: Colors color = static_cast<Colors>(5); // но делать так не рекомендуетсяииColors color = static_cast<Colors>(5); // но делать так не рекомендуется.
Компилятор также не позволит вам вводить перечислители через std::cin: std::cin >> color;
Однако, возможно ввести целое число, а затем использовать оператор static_cast, чтобы поместить целочисленное значение в перечисляемый тип:

int inputColor;
std::cin >> inputColor;
Colors color = static_cast<Colors>(inputColor);

Каждый перечисляемый тип считается отдельным типом. Следовательно, попытка присвоить перечислитель из одного перечисления перечислителю из другого — вызовет ошибку компиляции:
Animals animal = COLOR_BLUE;

Многие языки программирования используют перечисления для определения логических значений. По сути, логический тип данных — это простое перечисление всего лишь с двумя перечислителями: 
true и false! Однако в языке C++ значения true и false определены как ключевые слова вместо перечислителей.

в C++11 добавили классы enum (или «перечисления с областью видимости»), которые добавляют перечислениям локальную область видимости со всеми её правилами. 
Для создания такого класса нужно просто добавить ключевое слово class сразу после enum: enum class Colors{red, blue, yellow, ...};

Однако с добавлением класса, который ограничивает область видимости каждого перечислителя областью видимости его перечисления, 
для доступа к нему потребуется оператор разрешения области видимости (например, Colors::PINK). Это значительно снижает риск возникновения конфликтов имен.
Строгие правила типов классов enum означают, что каждый класс enum считается уникальным типом. Это означает, что компилятор не сможет сравнивать перечислители из разных перечислений.
Но можно сравнивать перечислители внутри одного класса enum (так как эти перечислители принадлежат одному типу).
С классами enum компилятор больше не сможет неявно конвертировать значения перечислителей в целые числа.

Ключевое слово typedef позволяет создавать псевдоним для любого типа данных и использовать его вместо фактического имени типа. Чтобы объявить typedef (использовать псевдоним типа) —
следует использовать ключевое слово typedef вместе с типом данных, для которого создается псевдоним, а затем, собственно, сам псевдоним: typedef double time_t (double How = time_t How)
С помощью typedef можно давать простые имена сложным типам данных, что сделает их проще как для использования, так и для понимания.
Обычно к псевдонимам typedef добавляют окончание _t, указывая, таким образом, что идентификатором является тип, а не переменная.

В C++11 ввели новый улучшенный синтаксис для typedef, который имитирует способ объявления переменных. Этот синтаксис называется type alias. С помощью type alias мы пишем имя, 
которое затем используется как синоним конкретного типа данных (т.е. принцип тот же, но синтаксис более удобен).

Эти два способа функционально эквивалентны:

	- typedef double time_t; // используем time_t в качестве псевдонима для типа double [TYPEDEF]
	- using time_t = double; // используем time_t в качестве псевдонима для типа double [TYPE ALIAS(C++11)]

ВНИМАНИЕ! - Ключевое слово using не имеет ничего общего с using-стейтментами. Это ключевое слово имеет различный функционал в зависимости от контекста.

ПРАВИЛО: Следует использовать type alias вместо typedef, если компилятор поддерживает C++11.


C++ позволяет создавать собственные ПОЛЬЗОВАТЕЛЬСКИЕ ТИПЫ ДАННЫХ. типы, которые группируют несколько отдельных переменных вместе. 
Одним из простейших пользовательских типов данных является СТРУКТУРА. Структура позволяет сгруппировать переменные разных типов в единое целое.
Для определения структуры используется ключевое слово STRUCT: 
	- struct Employee { short id; int age; double salary};

Переменные, являющиеся частью структуры, называются членами структуры (или «полями структуры»).
Employee — это простое объявление структуры. Хотя мы и указали компилятору, что она имеет переменные-члены, память под нее сейчас не выделяется. 
Имена структур принято писать с заглавной буквы, чтобы отличать их от имен переменных.  

Чтобы использовать структуру Employee, нам нужно просто объявить переменную типа Employee:
	- Employee john; // имя структуры Employee начинается с заглавной буквы, а переменная john - с маленькой.

Здесь мы определили переменную типа Employee с именем john. Как и в случае с обычными переменными, определение переменной, типом которой является структура, 
приведет к выделению памяти для этой переменной.

Объявить можно и несколько переменных одной структуры:
	- Employee john; // создаем отдельную структуру Employee для John-a
	- Employee james; // создаем отдельную структуру Employee для James-a

Когда объявляется переменная структуры, например, Employee john, то john ссылается на всю структуру. 
Для того, чтобы получить доступ к отдельным её членам, используется оператор выбора члена (.). 
Например, в коде, приведенном ниже, мы используем оператор выбора членов для инициализации каждого члена структуры:

	- Emploee john; // создаем отдельную структуру Employee для John-а
	- john.id = 8; // присваиваем значение члену id структуры john
	- john.age = 27; // присваиваем значение члену age структуры john
	- john.salary = 32.17; // присваиваем значение члену salary структуры john

Как и в случае с обычными переменными, переменные-члены структуры не инициализируются автоматически и обычно содержат мусор. Инициализировать их нужно вручную.
Переменные-члены структуры работают так же, как и простые переменные, поэтому с ними можно выполнять обычные арифметические операции и операции сравнения:
	
	- int totalAge = john.age + james.age;
	- if (john.salary > james.salary)
	- cout << "John makes more than James\n";

Инициализация структур путем присваивания значений каждому члену по порядку — занятие довольно громоздкое (особенно, если этих членов много), 
поэтому в языке C++ есть более быстрый способ инициализации структур — с помощью списка инициализаторов. 
Он позволяет инициализировать некоторые или все члены структуры во время объявления переменной типа struct:

	- Employee john = { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
	- Employee james = { 6, 29}; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

В C++11 также можно использовать uniform-инициализацию:

	- Employee john { 5, 27, 45000.0 }; // john.id = 5, john.age = 27, john.salary = 45000.0
	- Employee james { 6, 29 }; // james.id = 6, james.age = 29, james.salary = 0.0 (инициализация по умолчанию)

В C++11 добавили возможность присваивать нестатическим (обычным) членам структуры значения по умолчанию. Например:

	- struct Triangle {double length = 2.0; double width = 2.0}; 
	- int main () {Triangle z; /* length = width = 2.0; */ z.lengh = 3.0 // можно присваивать другие значения членам}

Большим преимуществом использования структур, нежели отдельных переменных, является возможность передать всю структуру в функцию, которая должна работать с её членами:

Функция также может возвращать структуру (это один из тех немногих случаев, когда функция может возвращать несколько переменных).

Одни структуры могут содержать другие структуры(Вложенные). Например:

	- struct Employee { short id; int age; double salary};

Как правило, размер структуры — это сумма размеров всех её членов, но не всегда! Например, рассмотрим структуру Employee. 
На большинстве платформ тип short занимает 2 байта, тип int — 4 байта, а тип double — 8 байт. Следовательно, ожидается, что Employee будет занимать 2 + 4 + 8 = 14 байт. 
Чтобы узнать точный размер Employee, мы можем воспользоваться оператором sizeof:

	- std::cout << "The size of Employee is " << sizeof(Employee) << "\n";

мы можем сказать только, что размер структуры будет, по крайней мере, не меньше суммы размеров всех её членов. 
Но он может быть и больше! По соображениям производительности компилятор иногда может добавлять «пробелы/промежутки» в структуры.

Невозможно использовать предварительное объявление для структур поскольку не происходит выделения памяти при их объявлении.
Это возможно обойти, поместив структуру в заголовочный файл.

Переменные типа struct подчиняются тем же правилам, что и обычные переменные. Поэтому, если требуется сделать переменную структуры доступной в нескольких файлах,
можно использовать ключевое слово extern.

До C++11 ключевое слово auto использовалось для явного указания, что переменная должна иметь автоматическую продолжительность жизни - auto int boo(7);
Однако, поскольку все переменные в новых версиях языка C++ по умолчанию имеют автоматическую продолжительность жизни (если явно не указать другой тип продолжительности жизни), 
ключевое слово auto стало лишним и, следовательно, устаревшим.

В C++11 значение ключевого слова auto изменилось.

Начиная с C++11, ключевое слово auto при инициализации переменной может использоваться вместо типа переменной, чтобы сообщить компилятору, 
что он должен присвоить тип переменной исходя из инициализируемого значения. Это называется выводом типа (или «автоматическим определением типа данных компилятором»).

	- auto x = 4.0; // 4.0 - это литерал типа double, поэтому и x должен быть типа double
	- auto y = 3 + 4; // выражение 3 + 4 обрабатывается как целочисленное, поэтому и переменная y должна быть типа int

Это работает даже с возвращаемыми значениями функций:

	- auto result = subtract(4, 3);

Это работает только с инициализированными переменными. Переменные, объявленные без инициализации, 
не могут использовать эту особенность (поскольку нет инициализируемого значения, и компилятор не может знать, какой тип данных присвоить переменной).

В C++14 функционал ключевого слова auto был расширен до автоматического определения типа возвращаемого значения функции
  
	auto subtract(int a, int b) {
	return a - b;}

Хотя это может показаться удобным, так делать не рекомендуется.

В C++11 появилась возможность использовать синтаксис типа возвращаемого значения trailing (или просто «trailing-синтаксис»), 
когда компилятор делает выводы о типе возвращаемого значения по конечной части прототипа функции.

	int subtract(int a, int b); 

В C++11 это можно записать как:

	auto subtract(int a, int b) -> int;

В этом случае auto не выполняет вывод типа — это всего лишь часть синтаксиса типа возвращаемого значения trailing.
